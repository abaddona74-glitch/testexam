{
  "updatedAt": "2026-01-26T11:24:00Z",
  "test_questions": [
    {
      "id": 1,
      "question": "Given the following Kotlin declarations:\n\n``````kotlin\nfun main() {\n val scores = mutableListOf(100, 95)\n scores.add(90)\n val limit = 50\n // limit = 60\n println(scores)\n}\n```\n\n1. What value is printed to the console when running the code before uncommenting Line 5?\n2. What happens if you uncomment limit = 60 (Line 5)? Explain the distinction between manipulating the scores list (Line 3) and attempting to reassign limit (Line 5).\n```",
      "options": {
        "A": "[100, 95, 90] - Compilation error at line 5",
        "B": "[100, 95, 90] - Runtime error at line 5",
        "C": "[100, 95] - Compilation error at line 5",
        "D": "[100, 95] - No error, value changes to 60"
      },
      "correct_answer": "A"
    },
    {
      "id": 2,
      "question": "Consider the following Kotlin code snippet:\n\n``````kotlin\nfun processData(data: String): Int {\n return data.length\n}\n\nfun main() {\n val nullableData: String? = null\n // print(processData(nullableData))\n val safeLength = nullableData?.length ?: 0\n println(safeLength)\n}\n```\n\n1. What is the output when only Line 10 executes?\n2. What is the result if Line 8 is uncommented? Justify the difference in behavior using Kotlin's Null Safety concepts.\n```",
      "options": {
        "A": "0 - Compilation error",
        "B": "null - Runtime NullPointerException",
        "C": "0 - Runtime NullPointerException",
        "D": "null - Compilation error"
      },
      "correct_answer": "A"
    },
    {
      "id": 3,
      "question": "In Kotlin, Lists are ordered collections that allow duplicate items, whereas Sets are unordered and only store unique items. Given:\n\n``````kotlin\nval listItems = listOf('Red', 'Green', 'Blue', 'Red', 'Green')\nval setItems = setOf('Red', 'Green', 'Blue', 'Red', 'Green')\nprintln(\"List: $listItems\")\nprintln(\"Set: $setItems\")\n```\n\nWhat is the exact output for both the List and the Set?\n```",
      "options": {
        "A": "List: [Red, Green, Blue] Set: [Red, Green, Blue]",
        "B": "List: [Red, Green, Blue, Red, Green] Set: [Red, Green, Blue, Red, Green]",
        "C": "List: [Red, Green, Blue, Red, Green] Set: [Red, Green, Blue]",
        "D": "List: [Red, Green, Blue] Set: [Red, Green, Blue, Red, Green]"
      },
      "correct_answer": "C"
    },
    {
      "id": 4,
      "question": "Given:\n\n``````kotlin\nfun sendAlert(recipient: String, priority: Int = 1, message: String) {\n println(\"Alert to $recipient (P$priority): $message\")\n}\n\nfun main() {\n sendAlert(message = \"System Down\", recipient = \"Admin\", priority = 5)\n}\n```\n\n1. What is the output of the main function?\n2. Why does this specific call succeed even though the arguments are provided in a different order than they are declared in the function header?\n```",
      "options": {
        "A": "Alert to Admin (P5): System Down - Because of named arguments",
        "B": "Alert to Admin (P1): System Down - Because of default arguments",
        "C": "Compilation error - Arguments must be in order",
        "D": "Alert to System Down (P5): Admin - Because arguments are swapped"
      },
      "correct_answer": "A"
    },
    {
      "id": 5,
      "question": "You define two entities:\n\n``````kotlin\nclass Employee(val name: String, val employeeId: Int)\ndata class User(val name: String, val id: Int)\n```\n\nIf you print an instance of Employee and an instance of User directly, which one will automatically produce a readable string representation of its properties, and what is the name of the predefined member function responsible for this feature?\n```",
      "options": {
        "A": "Employee - toString()",
        "B": "User - equals()",
        "C": "User - toString()",
        "D": "Both - toString()"
      },
      "correct_answer": "C"
    },
    {
      "id": 6,
      "question": "In Kotlin's Control Flow, both while and do-while loops execute code based on a condition. Explain the key difference between these two loops that guarantees the code block inside the loop will be executed at least once, regardless of the initial truthfulness of the condition.",
      "options": {
        "A": "do-while checks condition after executing the block",
        "B": "while checks condition before executing the block",
        "C": "Both check condition before executing",
        "D": "Both check condition after executing"
      },
      "correct_answer": "A"
    },
    {
      "id": 7,
      "question": "When using Android Studio (the official IDE for Android app development), which specific Tool Window is crucial for viewing real-time system messages and debugging logs while an application is running on an emulator or device?",
      "options": {
        "A": "Project Window",
        "B": "Run Window",
        "C": "Logcat",
        "D": "Debug Window"
      },
      "correct_answer": "C"
    },
    {
      "id": 8,
      "question": "In Git, if you have made several changes locally and are ready to save them to your local history, what are the two consecutive mandatory command-line interface (CLI) commands required to first prepare all modified files and then permanently save them with the message 'Feature complete'?",
      "options": {
        "A": "git add . ; git commit -m 'Feature complete'",
        "B": "git commit -m 'Feature complete' ; git push",
        "C": "git stage . ; git commit 'Feature complete'",
        "D": "git add . ; git push -m 'Feature complete'"
      },
      "correct_answer": "A"
    },
    {
      "id": 9,
      "question": "What restriction applies specifically to direct subclasses or implementations of a sealed class or sealed interface in Kotlin, which does not apply to indirect subclasses?",
      "options": {
        "A": "Direct subclasses must be marked as final and cannot be extended further.",
        "B": "Direct subclasses must be declared within the same file as the sealed type.",
        "C": "Direct subclasses must be declared within the same module and package as the sealed type.",
        "D": "Direct subclasses cannot contain any constructors, as the sealed class is inherently abstract."
      },
      "correct_answer": "C"
    },
    {
      "id": 10,
      "question": "In Clean Architecture, when an inner layer (A) needs to communicate with an outer layer (B), how is the Dependency Rule strictly enforced to ensure dependencies move inward?",
      "options": {
        "A": "Layer A directly imports Layer B's class, but Layer B is marked as internal to prevent external changes.",
        "B": "Layer B is always implemented as an abstract base class, which Layer A inherits from.",
        "C": "Layer A defines an abstract Interface (C) which specifies the required output format, and Layer B implements this Interface (C), thereby making B dependent on A's contract.",
        "D": "Layer A receives data from B through a static utility class, eliminating explicit dependency between A and B."
      },
      "correct_answer": "C"
    },
    {
      "id": 11,
      "question": "A sealed class itself is always abstract and cannot be instantiated directly. Regarding the visibility of its constructors, which pair of visibility modifiers is explicitly forbidden in Kotlin and will raise a compilation error?",
      "options": {
        "A": "protected and private.",
        "B": "internal and protected.",
        "C": "private and public.",
        "D": "public and internal."
      },
      "correct_answer": "A"
    },
    {
      "id": 12,
      "question": "Which two core principles are central to the MVI (Model-View-Intent) architectural pattern, ensuring predictability and stability, and distinguishing it strongly from MVVM?",
      "options": {
        "A": "Loose coupling via an observable ViewModel layer and a bidirectional data flow.",
        "B": "A passive View routing user actions to a Presenter, and a strict one-to-one View-Presenter relationship.",
        "C": "Unidirectional Data Flow (UDF) and the Immutability of the Model's state.",
        "D": "Controller acting as the central communication hub and Model having no knowledge of the View."
      },
      "correct_answer": "C"
    },
    {
      "id": 13,
      "question": "In the Android Clean Architecture implementation, both the Repository and Data Source classes reside in the Data Layer. Which one of the following responsibilities is specifically attributed to the Repository class, showcasing its role as an abstraction layer?",
      "options": {
        "A": "Working with only one single source of data (e.g., a network API).",
        "B": "Serving as the bridge between the application and the system for data operations.",
        "C": "Containing reusable, complex business logic that is reused by multiple ViewModels.",
        "D": "Resolving conflicts between multiple data sources."
      },
      "correct_answer": "D"
    },
    {
      "id": 14,
      "question": "You need to define a hierarchy where multiple unrelated types (classes from different base hierarchies) must implement a common characteristic or contract. Which special type should you use, and why?",
      "options": {
        "A": "enum class, because it offers a fixed set of named constants.",
        "B": "sealed class, because it is best for closed class hierarchies with varying data.",
        "C": "data class, because it allows for simple data storage and retrieval.",
        "D": "sealed interface, because it allows for flexible composition by enabling a type to implement multiple sealed interfaces across different hierarchies."
      },
      "correct_answer": "D"
    },
    {
      "id": 15,
      "question": "Match the MVVM architectural component with its primary role in the application flow:\n\n1. Acts as the intermediary; handles business logic and exposes observable data streams to the UI.\n2. Represents the user interface elements; displays data and captures user interactions.\n3. Manages data retrieval, storage, and interaction with data sources like databases or network APIs.",
      "options": {
        "A": "1-ViewModel, 2-View, 3-Model",
        "B": "1-Model, 2-View, 3-ViewModel",
        "C": "1-View, 2-ViewModel, 3-Model",
        "D": "1-ViewModel, 2-Model, 3-View"
      },
      "correct_answer": "A"
    },
    {
      "id": 16,
      "question": "Order the three standard layers of an Android application following the principles of Clean Architecture, starting with the Outermost Layer and moving inward.",
      "options": {
        "A": "Outermost Layer → UI Layer",
        "B": "Middle Layer → Domain Layer",
        "C": "Innermost Layer → Data Layer",
        "D": "Infrastructure → Hardware Layer"
      },
      "correct_answer": "A, B, C"
    },
    {
      "id": 17,
      "question": "Match the requirement for defining application constants or states with the most appropriate Kotlin special class:\n\n1. Fixed, simple, unique constants representing error severity levels (MINOR, MAJOR, CRITICAL)\n2. Representing network responses where each success/failure state needs unique, varying data properties\n3. Defining a set of common behaviors for different payment processing classes",
      "options": {
        "A": "1-enum class, 2-sealed class, 3-sealed interface",
        "B": "1-sealed class, 2-enum class, 3-sealed interface",
        "C": "1-data class, 2-sealed class, 3-enum class",
        "D": "1-sealed interface, 2-data class, 3-enum class"
      },
      "correct_answer": "A"
    },
    {
      "id": 18,
      "question": "Complete the sentences about MVP (Model-View-Presenter) pattern:\n\n* A. The ______ is a passive interface that is completely dumb and routes user actions to the Presenter.\n* B. The ______ relationship between the View and the Presenter is strictly.\n* C. The ______ is the 'middle man' that retrieves data from the Model and updates the View.",
      "options": {
        "A": "A: View, B: one-to-one, C: Presenter",
        "B": "A: Model, B: many-to-one, C: View",
        "C": "A: Presenter, B: one-to-one, C: Model",
        "D": "A: View, B: many-to-many, C: Presenter"
      },
      "correct_answer": "A"
    },
    {
      "id": 19,
      "question": "What happens when executing the following code?\n\n```kotlin\nfun main() {\n val immutableList = listOf(1, 2, 3)\n immutableList.add(4) // Line 4\n println(immutableList)\n}\n```\n",
      "options": {
        "A": "[1, 2, 3, 4] - No error",
        "B": "[1, 2, 3] - Compilation error at line 4",
        "C": "[1, 2, 3] - Runtime error at line 4",
        "D": "NullPointerException"
      },
      "correct_answer": "B"
    },
    {
      "id": 20,
      "question": "What is the result of the following code?\n\n```kotlin\nfun main() {\n val mutableSet = mutableSetOf(\"A\", \"B\", \"C\")\n val immutableSet = setOf(\"X\", \"Y\", \"Z\")\n \n mutableSet.add(\"D\")\n immutableSet.add(\"W\") // Line 6\n \n println(\"Mutable: $mutableSet\")\n println(\"Immutable: $immutableSet\")\n}\n```\n",
      "options": {
        "A": "Both sets get new elements added",
        "B": "Compilation error at line 6",
        "C": "Runtime error at line 6",
        "D": "Only mutable set gets the new element"
      },
      "correct_answer": "B"
    },
    {
      "id": 21,
      "question": "What is the output of this code?\n\n```kotlin\nfun main() {\n val numbers1 = mutableListOf(10, 20, 30)\n val numbers2 = numbers1.toList() // immutable copy\n \n numbers1.add(40)\n \n println(\"Mutable: $numbers1\")\n println(\"Immutable: $numbers2\")\n}\n```\n",
      "options": {
        "A": "Mutable: [10, 20, 30, 40] Immutable: [10, 20, 30, 40]",
        "B": "Mutable: [10, 20, 30] Immutable: [10, 20, 30, 40]",
        "C": "Mutable: [10, 20, 30, 40] Immutable: [10, 20, 30]",
        "D": "Compilation error"
      },
      "correct_answer": "C"
    },
    {
      "id": 22,
      "question": "Analyze this code:\n\n``````kotlin\nfun main() {\n val originalMap = mutableMapOf(\"a\" to 1, \"b\" to 2)\n val readOnlyMap: Map<String, Int> = originalMap\n \n originalMap[\"c\"] = 3\n readOnlyMap[\"d\"] = 4 // Line 6\n \n println(\"Original: $originalMap\")\n}\n```\n\nWhat happens at line 6?\n```",
      "options": {
        "A": "\"d\"→4 is added to the map",
        "B": "Compilation error",
        "C": "Runtime error",
        "D": "NullPointerException"
      },
      "correct_answer": "B"
    },
    {
      "id": 23,
      "question": "What does this program print?\n\n```kotlin\nfun main() {\n val mutableList = mutableListOf<Int>()\n val immutableList = listOf<Int>()\n \n mutableList.addAll(listOf(5, 10, 15))\n val newImmutableList = immutableList + 20\n \n println(\"Mutable: $mutableList\")\n println(\"New Immutable: $newImmutableList\")\n}\n```\n",
      "options": {
        "A": "Mutable: [5, 10, 15] New Immutable: [20]",
        "B": "Mutable: [] New Immutable: [20]",
        "C": "Compilation error",
        "D": "Mutable: [5, 10, 15] New Immutable: []"
      },
      "correct_answer": "A"
    },
    {
      "id": 24,
      "question": "Which of the following statements about Kotlin collections is CORRECT?",
      "options": {
        "A": "mutableListOf() creates a list that cannot be changed after initialization",
        "B": "listOf() creates a list that can be modified using add() method",
        "C": "toMutableList() converts an immutable list to a mutable one",
        "D": "Immutable collections are faster than mutable collections for all operations"
      },
      "correct_answer": "C"
    },
    {
      "id": 25,
      "question": "What is the output of this code?\n\n```kotlin\nfun main() {\n val immutable = setOf(1, 2, 3, 2, 1)\n val mutable = mutableSetOf(1, 2, 3, 2, 1)\n \n println(\"Immutable size: ${immutable.size}\")\n println(\"Mutable size: ${mutable.size}\")\n}\n```\n",
      "options": {
        "A": "Immutable size: 5, Mutable size: 5",
        "B": "Immutable size: 3, Mutable size: 5",
        "C": "Immutable size: 3, Mutable size: 3",
        "D": "Compilation error"
      },
      "correct_answer": "C"
    },
    {
      "id": 26,
      "question": "What happens when you try to compile this code?\n\n```kotlin\nfun modifyCollection(collection: MutableList<String>) {\n collection.add(\"Modified\")\n}\n\nfun main() {\n val list1 = mutableListOf(\"Original\")\n val list2 = listOf(\"Original\")\n \n modifyCollection(list1)\n modifyCollection(list2) // Line 10\n \n println(\"List1: $list1\")\n}\n```\n",
      "options": {
        "A": "Both lists get modified successfully",
        "B": "Compilation error at line 10",
        "C": "Runtime error at line 10",
        "D": "Only list1 gets modified"
      },
      "correct_answer": "B"
    },
    {
      "id": 27,
      "question": "What is the result of executing this code?\n\n```kotlin\nfun main() {\n val builderList = buildList {\n add(\"First\")\n add(\"Second\")\n }\n \n println(\"Type: ${builderList::class.simpleName}\")\n println(\"Size: ${builderList.size}\")\n}\n```\n",
      "options": {
        "A": "Type: ArrayList, Size: 2",
        "B": "Type: ImmutableCollections$ListN, Size: 2",
        "C": "Compilation error",
        "D": "Type: MutableList, Size: 2"
      },
      "correct_answer": "B"
    },
    {
      "id": 28,
      "question": "Which collection creation function guarantees that the returned collection cannot be modified?",
      "options": {
        "A": "mutableListOf()",
        "B": "arrayListOf()",
        "C": "listOf()",
        "D": "toMutableList()"
      },
      "correct_answer": "C"
    },
    {
    "id": 29,
    "question": "What does this code output?\n\n```kotlin\nfun main() {\n    val numbers = listOf(1, 2, 3, 4, 5)\n    val result = numbers\n        .filter { it % 2 == 0 }\n        .map { it * it }\n        .reduce { acc, i -> acc + i }\n    \n    println(result)\n}\n```",
    "options": {
      "A": "20",
      "B": "30",
      "C": "55",
      "D": "6"
    },
    "correct_answer": "A"
  },
  {
    "id": 30,
    "question": "Which of the following correctly demonstrates the use of a secondary constructor in a Kotlin class?",
    "options": {
      "A": "```kotlin\nclass Person(name: String) {\n    constructor(name: String, age: Int) : this(name)\n}\n```",
      "B": "```kotlin\nclass Person(name: String) {\n    constructor(name: String, age: Int)\n}\n```",
      "C": "```kotlin\nclass Person {\n    constructor(name: String)\n    constructor(name: String, age: Int)\n}\n```",
      "D": "```kotlin\nclass Person(name: String) {\n    secondary constructor(name: String, age: Int)\n}\n```"
    },
    "correct_answer": "A"
  },
  {
    "id": 31,
    "question": "In Android development, which component is responsible for managing the lifecycle of a Fragment?",
    "options": {
      "A": "Activity",
      "B": "ViewModel",
      "C": "FragmentManager",
      "D": "Application"
    },
    "correct_answer": "C"
  },
  {
    "id": 32,
    "question": "What is the purpose of the `@Composable` annotation in Jetpack Compose?",
    "options": {
      "A": "To mark a function as a UI component that can be recomposed",
      "B": "To indicate that a class is serializable",
      "C": "To enable data binding in XML layouts",
      "D": "To create dependency injection"
    },
    "correct_answer": "A"
  },
  {
    "id": 33,
    "question": "Which Room annotation is used to define a method that returns a list of items with a WHERE clause?",
    "options": {
      "A": "@Query",
      "B": "@Select",
      "C": "@Where",
      "D": "@Filter"
    },
    "correct_answer": "A"
  },
  {
    "id": 34,
    "question": "What does the following Kotlin code using coroutines output?\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    launch {\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n}\n```",
    "options": {
      "A": "Hello,\nWorld!",
      "B": "World!\nHello,",
      "C": "Hello, World! (on same line)",
      "D": "Compilation error"
    },
    "correct_answer": "A"
  },
  {
    "id": 35,
    "question": "In MVVM architecture, what is the recommended way for a ViewModel to communicate with the View?",
    "options": {
      "A": "Direct method calls",
      "B": "Using callbacks/interfaces",
      "C": "Through LiveData or StateFlow",
      "D": "Using SharedPreferences"
    },
    "correct_answer": "C"
  },
  {
    "id": 36,
    "question": "Which Gradle configuration file is used to define dependencies for an Android module?",
    "options": {
      "A": "settings.gradle",
      "B": "build.gradle (Project level)",
      "C": "build.gradle (Module level)",
      "D": "gradle.properties"
    },
    "correct_answer": "C"
  },
  {
    "id": 37,
    "question": "What is the difference between `val` and `var` in Kotlin?",
    "options": {
      "A": "`val` is for variables, `var` is for values",
      "B": "`val` is immutable (read-only), `var` is mutable",
      "C": "`val` is for primitive types, `var` is for objects",
      "D": "There is no difference"
    },
    "correct_answer": "B"
  },
  {
    "id": 38,
    "question": "In Android, which permission is required to access the internet?",
    "options": {
      "A": "<uses-permission android:name=\"android.permission.INTERNET\" />",
      "B": "<uses-permission android:name=\"android.permission.NETWORK\" />",
      "C": "<uses-permission android:name=\"android.permission.WIFI\" />",
      "D": "<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />"
    },
    "correct_answer": "A"
  },
  {
    "id": 39,
    "question": "What does the `suspend` modifier mean in Kotlin coroutines?",
    "options": {
      "A": "The function can be paused and resumed later",
      "B": "The function will be cancelled automatically",
      "C": "The function runs on the main thread",
      "D": "The function is synchronous"
    },
    "correct_answer": "A"
  },
  {
    "id": 40,
    "question": "Which lifecycle method is called when an Activity becomes visible to the user?",
    "options": {
      "A": "onCreate()",
      "B": "onStart()",
      "C": "onResume()",
      "D": "onVisible()"
    },
    "correct_answer": "B"
  },
  {
    "id": 41,
    "question": "What is the purpose of the `by lazy` delegate in Kotlin?",
    "options": {
      "A": "To create a thread-safe singleton",
      "B": "To initialize a property only when it's first accessed",
      "C": "To bind a property to another property",
      "D": "To make a property observable"
    },
    "correct_answer": "B"
  },
  {
    "id": 42,
    "question": "In Jetpack Compose, what is the difference between `remember` and `rememberSaveable`?",
    "options": {
      "A": "`remember` survives configuration changes, `rememberSaveable` doesn't",
      "B": "`rememberSaveable` survives configuration changes, `remember` doesn't",
      "C": "They are identical",
      "D": "`remember` is for state, `rememberSaveable` is for effects"
    },
    "correct_answer": "B"
  },
  {
    "id": 43,
    "question": "Which HTTP status code indicates a successful request in REST APIs?",
    "options": {
      "A": "200 OK",
      "B": "404 Not Found",
      "C": "500 Internal Server Error",
      "D": "301 Moved Permanently"
    },
    "correct_answer": "A"
  },
  {
    "id": 44,
    "question": "What is the purpose of the `Sealed` class in Kotlin?",
    "options": {
      "A": "To create immutable classes",
      "B": "To restrict class hierarchies to a fixed set of subtypes",
      "C": "To make classes serializable",
      "D": "To enable inheritance from multiple classes"
    },
    "correct_answer": "B"
  },
  {
    "id": 45,
    "question": "In Android, what is the difference between `dp` and `sp` units?",
    "options": {
      "A": "`dp` is density-independent pixels, `sp` is scale-independent pixels",
      "B": "`dp` is for width, `sp` is for height",
      "C": "`dp` is device pixels, `sp` is screen pixels",
      "D": "They are the same"
    },
    "correct_answer": "A"
  },
  {
    "id": 46,
    "question": "Which annotation is used to mark a function as a test in Kotlin with JUnit?",
    "options": {
      "A": "@Test",
      "B": "@RunWith",
      "C": "@Before",
      "D": "@After"
    },
    "correct_answer": "A"
  },
  {
    "id": 47,
    "question": "What does the following code using Kotlin flows output?\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking {\n    flow {\n        emit(1)\n        emit(2)\n        emit(3)\n    }\n    .filter { it % 2 == 1 }\n    .collect { println(it) }\n}\n```",
    "options": {
      "A": "1\n3",
      "B": "2",
      "C": "1\n2\n3",
      "D": "Compilation error"
    },
    "correct_answer": "A"
  },
  {
    "id": 48,
    "question": "Which component is NOT part of the Android Jetpack libraries?",
    "options": {
      "A": "Room",
      "B": "LiveData",
      "C": "Retrofit",
      "D": "ViewModel"
    },
    "correct_answer": "C"
  },
  {
    "id": 49,
    "question": "What is the purpose of the `companion object` in Kotlin classes?",
    "options": {
      "A": "To create static members",
      "B": "To implement interfaces",
      "C": "To enable inheritance",
      "D": "To make the class singleton"
    },
    "correct_answer": "A"
  },
  {
    "id": 50,
    "question": "In Clean Architecture, which layer should contain the business logic of the application?",
    "options": {
      "A": "Presentation Layer",
      "B": "Domain Layer",
      "C": "Data Layer",
      "D": "Infrastructure Layer"
    },
    "correct_answer": "B"
  }
  ]
}