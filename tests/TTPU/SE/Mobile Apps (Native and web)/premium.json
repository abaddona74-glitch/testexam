{
  "updatedAt": "2026-01-26T11:24:00Z",
  "test_questions": [
    {
      "id": 1,
      "question": "Given the following Kotlin declarations:\n\n``````kotlin\nfun main() {\n val scores = mutableListOf(100, 95)\n scores.add(90)\n val limit = 50\n // limit = 60\n println(scores)\n}\n```\n\n1. What value is printed to the console when running the code before uncommenting Line 5?\n2. What happens if you uncomment limit = 60 (Line 5)? Explain the distinction between manipulating the scores list (Line 3) and attempting to reassign limit (Line 5).\n```",
      "options": {
        "A": "[100, 95, 90] - Compilation error at line 5",
        "B": "[100, 95, 90] - Runtime error at line 5",
        "C": "[100, 95] - Compilation error at line 5",
        "D": "[100, 95] - No error, value changes to 60"
      },
      "correct_answer": "A"
    },
    {
      "id": 2,
      "question": "Consider the following Kotlin code snippet:\n\n``````kotlin\nfun processData(data: String): Int {\n return data.length\n}\n\nfun main() {\n val nullableData: String? = null\n // print(processData(nullableData))\n val safeLength = nullableData?.length ?: 0\n println(safeLength)\n}\n```\n\n1. What is the output when only Line 10 executes?\n2. What is the result if Line 8 is uncommented? Justify the difference in behavior using Kotlin's Null Safety concepts.\n```",
      "options": {
        "A": "0 - Compilation error",
        "B": "null - Runtime NullPointerException",
        "C": "0 - Runtime NullPointerException",
        "D": "null - Compilation error"
      },
      "correct_answer": "A"
    },
    {
      "id": 3,
      "question": "In Kotlin, Lists are ordered collections that allow duplicate items, whereas Sets are unordered and only store unique items. Given:\n\n``````kotlin\nval listItems = listOf('Red', 'Green', 'Blue', 'Red', 'Green')\nval setItems = setOf('Red', 'Green', 'Blue', 'Red', 'Green')\nprintln(\"List: $listItems\")\nprintln(\"Set: $setItems\")\n```\n\nWhat is the exact output for both the List and the Set?\n```",
      "options": {
        "A": "List: [Red, Green, Blue] Set: [Red, Green, Blue]",
        "B": "List: [Red, Green, Blue, Red, Green] Set: [Red, Green, Blue, Red, Green]",
        "C": "List: [Red, Green, Blue, Red, Green] Set: [Red, Green, Blue]",
        "D": "List: [Red, Green, Blue] Set: [Red, Green, Blue, Red, Green]"
      },
      "correct_answer": "C"
    },
    {
      "id": 4,
      "question": "Given:\n\n``````kotlin\nfun sendAlert(recipient: String, priority: Int = 1, message: String) {\n println(\"Alert to $recipient (P$priority): $message\")\n}\n\nfun main() {\n sendAlert(message = \"System Down\", recipient = \"Admin\", priority = 5)\n}\n```\n\n1. What is the output of the main function?\n2. Why does this specific call succeed even though the arguments are provided in a different order than they are declared in the function header?\n```",
      "options": {
        "A": "Alert to Admin (P5): System Down - Because of named arguments",
        "B": "Alert to Admin (P1): System Down - Because of default arguments",
        "C": "Compilation error - Arguments must be in order",
        "D": "Alert to System Down (P5): Admin - Because arguments are swapped"
      },
      "correct_answer": "A"
    },
    {
      "id": 5,
      "question": "You define two entities:\n\n``````kotlin\nclass Employee(val name: String, val employeeId: Int)\ndata class User(val name: String, val id: Int)\n```\n\nIf you print an instance of Employee and an instance of User directly, which one will automatically produce a readable string representation of its properties, and what is the name of the predefined member function responsible for this feature?\n```",
      "options": {
        "A": "Employee - toString()",
        "B": "User - equals()",
        "C": "User - toString()",
        "D": "Both - toString()"
      },
      "correct_answer": "C"
    },
    {
      "id": 6,
      "question": "In Kotlin's Control Flow, both while and do-while loops execute code based on a condition. Explain the key difference between these two loops that guarantees the code block inside the loop will be executed at least once, regardless of the initial truthfulness of the condition.",
      "options": {
        "A": "do-while checks condition after executing the block",
        "B": "while checks condition before executing the block",
        "C": "Both check condition before executing",
        "D": "Both check condition after executing"
      },
      "correct_answer": "A"
    },
    {
      "id": 7,
      "question": "When using Android Studio (the official IDE for Android app development), which specific Tool Window is crucial for viewing real-time system messages and debugging logs while an application is running on an emulator or device?",
      "options": {
        "A": "Project Window",
        "B": "Run Window",
        "C": "Logcat",
        "D": "Debug Window"
      },
      "correct_answer": "C"
    },
    {
      "id": 8,
      "question": "In Git, if you have made several changes locally and are ready to save them to your local history, what are the two consecutive mandatory command-line interface (CLI) commands required to first prepare all modified files and then permanently save them with the message 'Feature complete'?",
      "options": {
        "A": "git add . ; git commit -m 'Feature complete'",
        "B": "git commit -m 'Feature complete' ; git push",
        "C": "git stage . ; git commit 'Feature complete'",
        "D": "git add . ; git push -m 'Feature complete'"
      },
      "correct_answer": "A"
    },
    {
      "id": 9,
      "question": "What restriction applies specifically to direct subclasses or implementations of a sealed class or sealed interface in Kotlin, which does not apply to indirect subclasses?",
      "options": {
        "A": "Direct subclasses must be marked as final and cannot be extended further.",
        "B": "Direct subclasses must be declared within the same file as the sealed type.",
        "C": "Direct subclasses must be declared within the same module and package as the sealed type.",
        "D": "Direct subclasses cannot contain any constructors, as the sealed class is inherently abstract."
      },
      "correct_answer": "C"
    },
    {
      "id": 10,
      "question": "In Clean Architecture, when an inner layer (A) needs to communicate with an outer layer (B), how is the Dependency Rule strictly enforced to ensure dependencies move inward?",
      "options": {
        "A": "Layer A directly imports Layer B's class, but Layer B is marked as internal to prevent external changes.",
        "B": "Layer B is always implemented as an abstract base class, which Layer A inherits from.",
        "C": "Layer A defines an abstract Interface (C) which specifies the required output format, and Layer B implements this Interface (C), thereby making B dependent on A's contract.",
        "D": "Layer A receives data from B through a static utility class, eliminating explicit dependency between A and B."
      },
      "correct_answer": "C"
    },
    {
      "id": 11,
      "question": "A sealed class itself is always abstract and cannot be instantiated directly. Regarding the visibility of its constructors, which pair of visibility modifiers is explicitly forbidden in Kotlin and will raise a compilation error?",
      "options": {
        "A": "protected and private.",
        "B": "internal and protected.",
        "C": "private and public.",
        "D": "public and internal."
      },
      "correct_answer": "A"
    },
    {
      "id": 12,
      "question": "Which two core principles are central to the MVI (Model-View-Intent) architectural pattern, ensuring predictability and stability, and distinguishing it strongly from MVVM?",
      "options": {
        "A": "Loose coupling via an observable ViewModel layer and a bidirectional data flow.",
        "B": "A passive View routing user actions to a Presenter, and a strict one-to-one View-Presenter relationship.",
        "C": "Unidirectional Data Flow (UDF) and the Immutability of the Model's state.",
        "D": "Controller acting as the central communication hub and Model having no knowledge of the View."
      },
      "correct_answer": "C"
    },
    {
      "id": 13,
      "question": "In the Android Clean Architecture implementation, both the Repository and Data Source classes reside in the Data Layer. Which one of the following responsibilities is specifically attributed to the Repository class, showcasing its role as an abstraction layer?",
      "options": {
        "A": "Working with only one single source of data (e.g., a network API).",
        "B": "Serving as the bridge between the application and the system for data operations.",
        "C": "Containing reusable, complex business logic that is reused by multiple ViewModels.",
        "D": "Resolving conflicts between multiple data sources."
      },
      "correct_answer": "D"
    },
    {
      "id": 14,
      "question": "You need to define a hierarchy where multiple unrelated types (classes from different base hierarchies) must implement a common characteristic or contract. Which special type should you use, and why?",
      "options": {
        "A": "enum class, because it offers a fixed set of named constants.",
        "B": "sealed class, because it is best for closed class hierarchies with varying data.",
        "C": "data class, because it allows for simple data storage and retrieval.",
        "D": "sealed interface, because it allows for flexible composition by enabling a type to implement multiple sealed interfaces across different hierarchies."
      },
      "correct_answer": "D"
    },
    {
      "id": 15,
      "question": "Match the MVVM architectural component with its primary role in the application flow:\n\n1. Acts as the intermediary; handles business logic and exposes observable data streams to the UI.\n2. Represents the user interface elements; displays data and captures user interactions.\n3. Manages data retrieval, storage, and interaction with data sources like databases or network APIs.",
      "options": {
        "A": "1-ViewModel, 2-View, 3-Model",
        "B": "1-Model, 2-View, 3-ViewModel",
        "C": "1-View, 2-ViewModel, 3-Model",
        "D": "1-ViewModel, 2-Model, 3-View"
      },
      "correct_answer": "A"
    },
    {
      "id": 16,
      "question": "Order the three standard layers of an Android application following the principles of Clean Architecture, starting with the Outermost Layer and moving inward.",
      "options": {
        "A": "Outermost Layer → UI Layer",
        "B": "Middle Layer → Domain Layer",
        "C": "Innermost Layer → Data Layer",
        "D": "Infrastructure → Hardware Layer"
      },
      "correct_answer": "A, B, C"
    },
    {
      "id": 17,
      "question": "Match the requirement for defining application constants or states with the most appropriate Kotlin special class:\n\n1. Fixed, simple, unique constants representing error severity levels (MINOR, MAJOR, CRITICAL)\n2. Representing network responses where each success/failure state needs unique, varying data properties\n3. Defining a set of common behaviors for different payment processing classes",
      "options": {
        "A": "1-enum class, 2-sealed class, 3-sealed interface",
        "B": "1-sealed class, 2-enum class, 3-sealed interface",
        "C": "1-data class, 2-sealed class, 3-enum class",
        "D": "1-sealed interface, 2-data class, 3-enum class"
      },
      "correct_answer": "A"
    },
    {
      "id": 18,
      "question": "Complete the sentences about MVP (Model-View-Presenter) pattern:\n\n* A. The ______ is a passive interface that is completely dumb and routes user actions to the Presenter.\n* B. The ______ relationship between the View and the Presenter is strictly.\n* C. The ______ is the 'middle man' that retrieves data from the Model and updates the View.",
      "options": {
        "A": "A: View, B: one-to-one, C: Presenter",
        "B": "A: Model, B: many-to-one, C: View",
        "C": "A: Presenter, B: one-to-one, C: Model",
        "D": "A: View, B: many-to-many, C: Presenter"
      },
      "correct_answer": "A"
    },
    {
      "id": 19,
      "question": "What happens when executing the following code?\n\n```kotlin\nfun main() {\n val immutableList = listOf(1, 2, 3)\n immutableList.add(4) // Line 4\n println(immutableList)\n}\n```\n",
      "options": {
        "A": "[1, 2, 3, 4] - No error",
        "B": "[1, 2, 3] - Compilation error at line 4",
        "C": "[1, 2, 3] - Runtime error at line 4",
        "D": "NullPointerException"
      },
      "correct_answer": "B"
    },
    {
      "id": 20,
      "question": "What is the result of the following code?\n\n```kotlin\nfun main() {\n val mutableSet = mutableSetOf(\"A\", \"B\", \"C\")\n val immutableSet = setOf(\"X\", \"Y\", \"Z\")\n \n mutableSet.add(\"D\")\n immutableSet.add(\"W\") // Line 6\n \n println(\"Mutable: $mutableSet\")\n println(\"Immutable: $immutableSet\")\n}\n```\n",
      "options": {
        "A": "Both sets get new elements added",
        "B": "Compilation error at line 6",
        "C": "Runtime error at line 6",
        "D": "Only mutable set gets the new element"
      },
      "correct_answer": "B"
    },
    {
      "id": 21,
      "question": "What is the output of this code?\n\n```kotlin\nfun main() {\n val numbers1 = mutableListOf(10, 20, 30)\n val numbers2 = numbers1.toList() // immutable copy\n \n numbers1.add(40)\n \n println(\"Mutable: $numbers1\")\n println(\"Immutable: $numbers2\")\n}\n```\n",
      "options": {
        "A": "Mutable: [10, 20, 30, 40] Immutable: [10, 20, 30, 40]",
        "B": "Mutable: [10, 20, 30] Immutable: [10, 20, 30, 40]",
        "C": "Mutable: [10, 20, 30, 40] Immutable: [10, 20, 30]",
        "D": "Compilation error"
      },
      "correct_answer": "C"
    },
    {
      "id": 22,
      "question": "Analyze this code:\n\n``````kotlin\nfun main() {\n val originalMap = mutableMapOf(\"a\" to 1, \"b\" to 2)\n val readOnlyMap: Map<String, Int> = originalMap\n \n originalMap[\"c\"] = 3\n readOnlyMap[\"d\"] = 4 // Line 6\n \n println(\"Original: $originalMap\")\n}\n```\n\nWhat happens at line 6?\n```",
      "options": {
        "A": "\"d\"→4 is added to the map",
        "B": "Compilation error",
        "C": "Runtime error",
        "D": "NullPointerException"
      },
      "correct_answer": "B"
    },
    {
      "id": 23,
      "question": "What does this program print?\n\n```kotlin\nfun main() {\n val mutableList = mutableListOf<Int>()\n val immutableList = listOf<Int>()\n \n mutableList.addAll(listOf(5, 10, 15))\n val newImmutableList = immutableList + 20\n \n println(\"Mutable: $mutableList\")\n println(\"New Immutable: $newImmutableList\")\n}\n```\n",
      "options": {
        "A": "Mutable: [5, 10, 15] New Immutable: [20]",
        "B": "Mutable: [] New Immutable: [20]",
        "C": "Compilation error",
        "D": "Mutable: [5, 10, 15] New Immutable: []"
      },
      "correct_answer": "A"
    },
    {
      "id": 24,
      "question": "Which of the following statements about Kotlin collections is CORRECT?",
      "options": {
        "A": "mutableListOf() creates a list that cannot be changed after initialization",
        "B": "listOf() creates a list that can be modified using add() method",
        "C": "toMutableList() converts an immutable list to a mutable one",
        "D": "Immutable collections are faster than mutable collections for all operations"
      },
      "correct_answer": "C"
    },
    {
      "id": 25,
      "question": "What is the output of this code?\n\n```kotlin\nfun main() {\n val immutable = setOf(1, 2, 3, 2, 1)\n val mutable = mutableSetOf(1, 2, 3, 2, 1)\n \n println(\"Immutable size: ${immutable.size}\")\n println(\"Mutable size: ${mutable.size}\")\n}\n```\n",
      "options": {
        "A": "Immutable size: 5, Mutable size: 5",
        "B": "Immutable size: 3, Mutable size: 5",
        "C": "Immutable size: 3, Mutable size: 3",
        "D": "Compilation error"
      },
      "correct_answer": "C"
    },
    {
      "id": 26,
      "question": "What happens when you try to compile this code?\n\n```kotlin\nfun modifyCollection(collection: MutableList<String>) {\n collection.add(\"Modified\")\n}\n\nfun main() {\n val list1 = mutableListOf(\"Original\")\n val list2 = listOf(\"Original\")\n \n modifyCollection(list1)\n modifyCollection(list2) // Line 10\n \n println(\"List1: $list1\")\n}\n```\n",
      "options": {
        "A": "Both lists get modified successfully",
        "B": "Compilation error at line 10",
        "C": "Runtime error at line 10",
        "D": "Only list1 gets modified"
      },
      "correct_answer": "B"
    },
    {
      "id": 27,
      "question": "What is the result of executing this code?\n\n```kotlin\nfun main() {\n val builderList = buildList {\n add(\"First\")\n add(\"Second\")\n }\n \n println(\"Type: ${builderList::class.simpleName}\")\n println(\"Size: ${builderList.size}\")\n}\n```\n",
      "options": {
        "A": "Type: ArrayList, Size: 2",
        "B": "Type: ImmutableCollections$ListN, Size: 2",
        "C": "Compilation error",
        "D": "Type: MutableList, Size: 2"
      },
      "correct_answer": "B"
    },
    {
      "id": 28,
      "question": "Which collection creation function guarantees that the returned collection cannot be modified?",
      "options": {
        "A": "mutableListOf()",
        "B": "arrayListOf()",
        "C": "listOf()",
        "D": "toMutableList()"
      },
      "correct_answer": "C"
    },
    {
    "id": 29,
    "question": "What does this code output?\n\n```kotlin\nfun main() {\n    val numbers = listOf(1, 2, 3, 4, 5)\n    val result = numbers\n        .filter { it % 2 == 0 }\n        .map { it * it }\n        .reduce { acc, i -> acc + i }\n    \n    println(result)\n}\n```",
    "options": {
      "A": "20",
      "B": "30",
      "C": "55",
      "D": "6"
    },
    "correct_answer": "A"
  },
  {
    "id": 30,
    "question": "Which of the following correctly demonstrates the use of a secondary constructor in a Kotlin class?",
    "options": {
      "A": "```kotlin\nclass Person(name: String) {\n    constructor(name: String, age: Int) : this(name)\n}\n```",
      "B": "```kotlin\nclass Person(name: String) {\n    constructor(name: String, age: Int)\n}\n```",
      "C": "```kotlin\nclass Person {\n    constructor(name: String)\n    constructor(name: String, age: Int)\n}\n```",
      "D": "```kotlin\nclass Person(name: String) {\n    secondary constructor(name: String, age: Int)\n}\n```"
    },
    "correct_answer": "A"
  },
  {
    "id": 31,
    "question": "In Android development, which component is responsible for managing the lifecycle of a Fragment?",
    "options": {
      "A": "Activity",
      "B": "ViewModel",
      "C": "FragmentManager",
      "D": "Application"
    },
    "correct_answer": "C"
  },
  {
    "id": 32,
    "question": "What is the purpose of the `@Composable` annotation in Jetpack Compose?",
    "options": {
      "A": "To mark a function as a UI component that can be recomposed",
      "B": "To indicate that a class is serializable",
      "C": "To enable data binding in XML layouts",
      "D": "To create dependency injection"
    },
    "correct_answer": "A"
  },
  {
    "id": 33,
    "question": "Which Room annotation is used to define a method that returns a list of items with a WHERE clause?",
    "options": {
      "A": "@Query",
      "B": "@Select",
      "C": "@Where",
      "D": "@Filter"
    },
    "correct_answer": "A"
  },
  {
    "id": 34,
    "question": "What does the following Kotlin code using coroutines output?\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    launch {\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n}\n```",
    "options": {
      "A": "Hello,\nWorld!",
      "B": "World!\nHello,",
      "C": "Hello, World! (on same line)",
      "D": "Compilation error"
    },
    "correct_answer": "A"
  },
  {
    "id": 35,
    "question": "In MVVM architecture, what is the recommended way for a ViewModel to communicate with the View?",
    "options": {
      "A": "Direct method calls",
      "B": "Using callbacks/interfaces",
      "C": "Through LiveData or StateFlow",
      "D": "Using SharedPreferences"
    },
    "correct_answer": "C"
  },
  {
    "id": 36,
    "question": "Which Gradle configuration file is used to define dependencies for an Android module?",
    "options": {
      "A": "settings.gradle",
      "B": "build.gradle (Project level)",
      "C": "build.gradle (Module level)",
      "D": "gradle.properties"
    },
    "correct_answer": "C"
  },
  {
    "id": 37,
    "question": "What is the difference between `val` and `var` in Kotlin?",
    "options": {
      "A": "`val` is for variables, `var` is for values",
      "B": "`val` is immutable (read-only), `var` is mutable",
      "C": "`val` is for primitive types, `var` is for objects",
      "D": "There is no difference"
    },
    "correct_answer": "B"
  },
  {
    "id": 38,
    "question": "In Android, which permission is required to access the internet?",
    "options": {
      "A": "<uses-permission android:name=\"android.permission.INTERNET\" />",
      "B": "<uses-permission android:name=\"android.permission.NETWORK\" />",
      "C": "<uses-permission android:name=\"android.permission.WIFI\" />",
      "D": "<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />"
    },
    "correct_answer": "A"
  },
  {
    "id": 39,
    "question": "What does the `suspend` modifier mean in Kotlin coroutines?",
    "options": {
      "A": "The function can be paused and resumed later",
      "B": "The function will be cancelled automatically",
      "C": "The function runs on the main thread",
      "D": "The function is synchronous"
    },
    "correct_answer": "A"
  },
  {
    "id": 40,
    "question": "Which lifecycle method is called when an Activity becomes visible to the user?",
    "options": {
      "A": "onCreate()",
      "B": "onStart()",
      "C": "onResume()",
      "D": "onVisible()"
    },
    "correct_answer": "B"
  },
  {
    "id": 41,
    "question": "What is the purpose of the `by lazy` delegate in Kotlin?",
    "options": {
      "A": "To create a thread-safe singleton",
      "B": "To initialize a property only when it's first accessed",
      "C": "To bind a property to another property",
      "D": "To make a property observable"
    },
    "correct_answer": "B"
  },
  {
    "id": 42,
    "question": "In Jetpack Compose, what is the difference between `remember` and `rememberSaveable`?",
    "options": {
      "A": "`remember` survives configuration changes, `rememberSaveable` doesn't",
      "B": "`rememberSaveable` survives configuration changes, `remember` doesn't",
      "C": "They are identical",
      "D": "`remember` is for state, `rememberSaveable` is for effects"
    },
    "correct_answer": "B"
  },
  {
    "id": 43,
    "question": "Which HTTP status code indicates a successful request in REST APIs?",
    "options": {
      "A": "200 OK",
      "B": "404 Not Found",
      "C": "500 Internal Server Error",
      "D": "301 Moved Permanently"
    },
    "correct_answer": "A"
  },
  {
    "id": 44,
    "question": "What is the purpose of the `Sealed` class in Kotlin?",
    "options": {
      "A": "To create immutable classes",
      "B": "To restrict class hierarchies to a fixed set of subtypes",
      "C": "To make classes serializable",
      "D": "To enable inheritance from multiple classes"
    },
    "correct_answer": "B"
  },
  {
    "id": 45,
    "question": "In Android, what is the difference between `dp` and `sp` units?",
    "options": {
      "A": "`dp` is density-independent pixels, `sp` is scale-independent pixels",
      "B": "`dp` is for width, `sp` is for height",
      "C": "`dp` is device pixels, `sp` is screen pixels",
      "D": "They are the same"
    },
    "correct_answer": "A"
  },
  {
    "id": 46,
    "question": "Which annotation is used to mark a function as a test in Kotlin with JUnit?",
    "options": {
      "A": "@Test",
      "B": "@RunWith",
      "C": "@Before",
      "D": "@After"
    },
    "correct_answer": "A"
  },
  {
    "id": 47,
    "question": "What does the following code using Kotlin flows output?\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun main() = runBlocking {\n    flow {\n        emit(1)\n        emit(2)\n        emit(3)\n    }\n    .filter { it % 2 == 1 }\n    .collect { println(it) }\n}\n```",
    "options": {
      "A": "1\n3",
      "B": "2",
      "C": "1\n2\n3",
      "D": "Compilation error"
    },
    "correct_answer": "A"
  },
  {
    "id": 48,
    "question": "Which component is NOT part of the Android Jetpack libraries?",
    "options": {
      "A": "Room",
      "B": "LiveData",
      "C": "Retrofit",
      "D": "ViewModel"
    },
    "correct_answer": "C"
  },
  {
    "id": 49,
    "question": "What is the purpose of the `companion object` in Kotlin classes?",
    "options": {
      "A": "To create static members",
      "B": "To implement interfaces",
      "C": "To enable inheritance",
      "D": "To make the class singleton"
    },
    "correct_answer": "A"
  },
  {
    "id": 50,
    "question": "In Clean Architecture, which layer should contain the business logic of the application?",
    "options": {
      "A": "Presentation Layer",
      "B": "Domain Layer",
      "C": "Data Layer",
      "D": "Infrastructure Layer"
    },
    "correct_answer": "B"
  },
  {
    "id": 51,
    "question": "What is the output of this null safety code?\n\n```kotlin\nfun main() {\n    val name: String? = null\n    val length = name?.length ?: 0\n    println(\"Length: $length\")\n}\n```",
    "options": {
      "A": "Length: null",
      "B": "Length: 0",
      "C": "NullPointerException",
      "D": "Compilation error"
    },
    "correct_answer": "B"
  },
  {
    "id": 52,
    "question": "What does the `!!` operator do in Kotlin?",
    "options": {
      "A": "Converts a nullable type to non-nullable and throws NPE if null",
      "B": "Checks if a value is null and returns default",
      "C": "Makes a variable immutable",
      "D": "Creates a safe call"
    },
    "correct_answer": "A"
  },
  {
    "id": 53,
    "question": "Which of these correctly demonstrates safe calls with chaining?\n\n```kotlin\n// Assume: data class Person(val address: Address?)\n// data class Address(val street: Street?)\n// data class Street(val name: String?)\n```",
    "options": {
      "A": "```kotlin\nval streetName = person.address.street.name\n```",
      "B": "```kotlin\nval streetName = person?.address?.street?.name\n```",
      "C": "```kotlin\nval streetName = person!!.address!!.street!!.name\n```",
      "D": "```kotlin\nval streetName = person.address?.street?.name\n```"
    },
    "correct_answer": "B"
  },
  {
    "id": 54,
    "question": "What is the result of this code?\n\n```kotlin\nfun main() {\n    val str: String? = \"Hello\"\n    val result = str?.let {\n        it.length\n    } ?: run {\n        -1\n    }\n    println(result)\n}\n```",
    "options": {
      "A": "5",
      "B": "-1",
      "C": "null",
      "D": "Compilation error"
    },
    "correct_answer": "A"
  },
  {
    "id": 55,
    "question": "How does `?:` (Elvis operator) differ from regular `if-else` for null checks?",
    "options": {
      "A": "Elvis operator is only for nullable types, if-else is general",
      "B": "Elvis operator returns an expression, if-else is a statement",
      "C": "Elvis operator is more efficient",
      "D": "All of the above"
    },
    "correct_answer": "B"
  },
  {
    "id": 56,
    "question": "What will this code print?\n\n```kotlin\nfun process(value: String?) {\n    val result = value?.takeIf { it.isNotEmpty() } ?: \"Default\"\n    println(result)\n}\n\nfun main() {\n    process(null)\n    process(\"\")\n    process(\"Kotlin\")\n}\n```",
    "options": {
      "A": "Default\nDefault\nKotlin",
      "B": "null\n\nKotlin",
      "C": "Default\n\nKotlin",
      "D": "Compilation error"
    },
    "correct_answer": "A"
  },
  {
    "id": 57,
    "question": "Which Kotlin function is used to throw an exception if a value is null?",
    "options": {
      "A": "requireNotNull()",
      "B": "checkNotNull()",
      "C": "error()",
      "D": "All of the above"
    },
    "correct_answer": "D"
  },
  {
    "id": 58,
    "question": "What is the difference between `?.let` and `?:` for null handling?",
    "options": {
      "A": "`?.let` executes block if not null, `?:` provides default if null",
      "B": "They are identical",
      "C": "`?.let` is for functions, `?:` is for variables",
      "D": "`?.let` returns null, `?:` throws exception"
    },
    "correct_answer": "A"
  },
  {
    "id": 59,
    "question": "What does this code output?\n\n```kotlin\nfun main() {\n    val numbers: List<Int>? = listOf(1, 2, 3)\n    val size = numbers?.size ?: 0\n    val sum = numbers?.sum() ?: 0\n    \n    println(\"Size: $size, Sum: $sum\")\n}\n```",
    "options": {
      "A": "Size: 3, Sum: 6",
      "B": "Size: 0, Sum: 0",
      "C": "Size: null, Sum: null",
      "D": "NullPointerException"
    },
    "correct_answer": "A"
  },
  {
    "id": 60,
    "question": "Which of these will cause a compilation error in Kotlin?\n\n```kotlin\n// Assume: fun getLength(s: String): Int = s.length\n```",
    "options": {
      "A": "```kotlin\nval str: String? = null\nval length = getLength(str)\n```",
      "B": "```kotlin\nval str: String? = null\nval length = str?.let { getLength(it) }\n```",
      "C": "```kotlin\nval str: String? = null\nval length = str?.length ?: 0\n```",
      "D": "```kotlin\nval str: String? = null\nval length = if (str != null) getLength(str) else 0\n```"
    },
    "correct_answer": "A"
  },
  {
    "id": 61,
    "question": "What is the purpose of the `as?` operator in Kotlin?",
    "options": {
      "A": "Safe type cast that returns null if cast fails",
      "B": "Unsafe type cast that throws exception",
      "C": "Checks if object is of certain type",
      "D": "Converts nullable to non-nullable"
    },
    "correct_answer": "A"
  },
  {
    "id": 62,
    "question": "What will be printed?\n\n```kotlin\nfun main() {\n    val map: Map<String, String?> = mapOf(\n        \"a\" to \"Apple\",\n        \"b\" to null,\n        \"c\" to \"Cherry\"\n    )\n    \n    val values = listOf(\"a\", \"b\", \"c\", \"d\")\n        .mapNotNull { key -> map[key] }\n    \n    println(values)\n}\n```",
    "options": {
      "A": "[Apple, null, Cherry]",
      "B": "[Apple, Cherry]",
      "C": "[Apple, null, Cherry, null]",
      "D": "NullPointerException"
    },
    "correct_answer": "B"
  },
  {
    "id": 63,
    "question": "How can you provide a default value when a nullable list is null or empty?",
    "options": {
      "A": "```kotlin\nlist?.ifEmpty { listOf(\"default\") } ?: listOf(\"default\")\n```",
      "B": "```kotlin\nlist ?: emptyList<String>()\n```",
      "C": "```kotlin\nlist.orEmpty().ifEmpty { listOf(\"default\") }\n```",
      "D": "All of the above"
    },
    "correct_answer": "C"
  },
  {
    "id": 64,
    "question": "What is the difference between `?.` and `!!` operators?",
    "options": {
      "A": "`?.` returns null if left side is null, `!!` throws NPE",
      "B": "`?.` is for functions, `!!` is for properties",
      "C": "`?.` is unsafe, `!!` is safe",
      "D": "There is no difference"
    },
    "correct_answer": "A"
  },
  {
    "id": 65,
    "question": "What does this code using `also` and null safety print?\n\n```kotlin\nfun main() {\n    var count: Int? = null\n    \n    count = count?.also {\n        it + 1\n    } ?: 1\n    \n    println(count)\n}\n```",
    "options": {
      "A": "null",
      "B": "1",
      "C": "0",
      "D": "Compilation error"
    },
    "correct_answer": "B"
  },
  {
      "id": 66,
      "question": "In Android XML layouts, what is the correct way to reference an Activity class in the `tools:context` attribute?",
      "options": {
        "A": "tools:context=\".MainActivity\"",
        "B": "tools:context=\"android.app.Activity\"",
        "C": "tools:context=\"@string/app_name\"",
        "D": "tools:context=\"MainActivity\""
      },
      "correct_answer": "A"
    },
    

    {
      "id": 67,
      "question": "Which XML tag should be used as the root element in a navigation graph file?",
      "options": {
        "A": "<android.support.v4.app.Fragment>",
        "B": "<navigation>",
        "C": "<fragment-container>",
        "D": "<graph>"
      },
      "correct_answer": "B"
    },
    

    {
      "id": 68,
      "question": "What happens when you start the same Activity from within its own onCreate() method?",
      "options": {
        "A": "Creates an infinite loop of Activity creation",
        "B": "The app crashes immediately",
        "C": "Nothing happens - it's ignored",
        "D": "Creates a new instance in back stack"
      },
      "correct_answer": "A"
    },
    

    {
      "id": 69,
      "question": "How do you properly check if an EditText has content before proceeding?",
      "options": {
        "A": "if (editText.text.isNotEmpty()) { ... }",
        "B": "if (editText != null) { ... }",
        "C": "if (editText.text.toString() != \"\") { ... }",
        "D": "Both A and C"
      },
      "correct_answer": "D"
    },
    

    {
      "id": 70,
      "question": "Where should you initialize a ViewModel in a Fragment for proper lifecycle management?",
      "options": {
        "A": "In onCreate()",
        "B": "In onCreateView()",
        "C": "In onViewCreated()",
        "D": "In onStart()"
      },
      "correct_answer": "C"
    },
    

    {
      "id": 71,
      "question": "In MVVM pattern, how should a Fragment observe changes from ViewModel?",
      "options": {
        "A": "Using direct method calls",
        "B": "Observing LiveData in onViewCreated()",
        "C": "Using callbacks/interfaces",
        "D": "Through SharedPreferences"
      },
      "correct_answer": "B"
    },
    

    {
      "id": 72,
      "question": "What Room annotation is required for a method that returns LiveData<List<Item>>?",
      "options": {
        "A": "@Query",
        "B": "@Select",
        "C": "@LiveData",
        "D": "@Observe"
      },
      "correct_answer": "A"
    },
    

    {
      "id": 73,
      "question": "What is the correct way to get SharedPreferences instance?",
      "options": {
        "A": "getSharedPreferences(\"my_prefs\", Context.MODE_PRIVATE)",
        "B": "SharedPreferences.getInstance(\"my_prefs\")",
        "C": "PreferenceManager.getDefaultSharedPreferences(context)",
        "D": "Both A and C"
      },
      "correct_answer": "D"
    },
    

    {
      "id": 74,
      "question": "When saving data with SharedPreferences, which method is preferred for better performance?",
      "options": {
        "A": "editor.commit()",
        "B": "editor.apply()",
        "C": "editor.save()",
        "D": "editor.flush()"
      },
      "correct_answer": "B"
    },
    
    {
      "id": 75,
      "question": "What should a Room Database class extend?",
      "options": {
        "A": "RoomDatabase",
        "B": "SQLiteOpenHelper",
        "C": "Database",
        "D": "BaseDatabase"
      },
      "correct_answer": "A"
    },
    

    {
      "id": 76,
      "question": "Which of these is a correct Room DAO method signature for inserting an item?",
      "options": {
        "A": "@Insert\nfun insert(item: Item): Long",
        "B": "@Insert\nsuspend fun insert(item: Item)",
        "C": "@Query(\"INSERT INTO items VALUES (:item)\")\nfun insert(item: Item)",
        "D": "Both A and B"
      },
      "correct_answer": "D"
    },
    {
      "id": 77,
      "question": "What lifecycle method is called when a Fragment's UI is ready for interaction?",
      "options": {
        "A": "onCreate()",
        "B": "onCreateView()",
        "C": "onViewCreated()",
        "D": "onResume()"
      },
      "correct_answer": "C"
    },
    {
      "id": 78,
      "question": "How do you pass data between Activities using Intent?",
      "options": {
        "A": "intent.putExtra(\"key\", value)",
        "B": "intent.setData(value)",
        "C": "intent.addArgument(\"key\", value)",
        "D": "intent.storeExtra(\"key\", value)"
      },
      "correct_answer": "A"
    },
    {
      "id": 79,
      "question": "What is the purpose of ViewModel in Android Architecture Components?",
      "options": {
        "A": "To store UI-related data that survives configuration changes",
        "B": "To handle business logic separately from UI",
        "C": "To observe data changes and update UI",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 80,
      "question": "Which of these is NOT a valid way to create a Fragment?",
      "options": {
        "A": "MyFragment()",
        "B": "MyFragment.newInstance()",
        "C": "Fragment(MyFragment::class.java)",
        "D": "supportFragmentManager.findFragmentById(R.id.fragment)"
      },
      "correct_answer": "C"
    },
     {
      "id": 81,
      "question": "What is the correct way to use Fragment Factory with Dependency Injection?",
      "options": {
        "A": "Use constructor injection in Fragment and provide FragmentFactory",
        "B": "Pass dependencies through Fragment arguments only",
        "C": "Use ServiceLocator pattern inside Fragment",
        "D": "All dependencies should be in Application class"
      },
      "correct_answer": "A"
    },
    {
      "id": 82,
      "question": "In Jetpack Compose, what is the difference between LaunchedEffect and rememberCoroutineScope?",
      "options": {
        "A": "LaunchedEffect - for one-shot side effects, rememberCoroutineScope - for ongoing coroutines",
        "B": "LaunchedEffect - automatically cancels when leaves composition, rememberCoroutineScope - manual cancellation needed",
        "C": "Both can be used for coroutines but in different scenarios",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 83,
      "question": "Which Clean Architecture layer should contain the API models and database entities?",
      "options": {
        "A": "Domain Layer",
        "B": "Presentation Layer",
        "C": "Data Layer",
        "D": "Network Layer"
      },
      "correct_answer": "C"
    },
    {
      "id": 84,
      "question": "What is the purpose of the BuildConfig class in Android?",
      "options": {
        "A": "To store build-specific configurations",
        "B": "To differentiate between debug and release builds",
        "C": "To store API keys and environment variables",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 85,
      "question": "Why should you use ViewBinding instead of findViewById?",
      "options": {
        "A": "Type safety and null safety",
        "B": "Better performance",
        "C": "Prevents memory leaks",
        "D": "Both A and B"
      },
      "correct_answer": "D"
    },
    {
      "id": 86,
      "question": "In MVVM with Kotlin Flow, how should you expose errors from ViewModel to View?",
      "options": {
        "A": "Using a separate LiveData/StateFlow for errors",
        "B": "Using sealed class wrapper for UI state",
        "C": "Throwing exceptions and catching in View",
        "D": "Both A and B"
      },
      "correct_answer": "D"
    },
    {
      "id": 87,
      "question": "What is the difference between suspendCoroutine and callbackFlow?",
      "options": {
        "A": "suspendCoroutine - for single async operation, callbackFlow - for stream of data",
        "B": "suspendCoroutine converts callback to suspend function",
        "C": "callbackFlow creates a Flow from callback-based API",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 88,
      "question": "Why use Navigation Component instead of manual Fragment transactions?",
      "options": {
        "A": "Handles back stack automatically",
        "B": "Type-safe arguments with Safe Args",
        "C": "Visual navigation graph in Android Studio",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 89,
      "question": "What is the purpose of using @AssistedInject in Hilt?",
      "options": {
        "A": "To inject dependencies that are known at runtime",
        "B": "For ViewModel injection with SavedStateHandle",
        "C": "When some dependencies need to be passed manually",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 90,
      "question": "How does Room handle database migrations?",
      "options": {
        "A": "Using Migration class with SQL statements",
        "B": "Automatically for additive changes",
        "C": "Can destroy and recreate with fallback",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 91,
      "question": "What is the benefit of using Single Activity Architecture?",
      "options": {
        "A": "Simpler navigation management",
        "B": "Better performance with Fragment transactions",
        "C": "Easier deep linking implementation",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 92,
      "question": "In Compose, when should you use derivedStateOf?",
      "options": {
        "A": "When a state is calculated from other states",
        "B": "To prevent unnecessary recompositions",
        "C": "When computation is expensive",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 93,
      "question": "Why separate data classes for API, Database, and Domain layers?",
      "options": {
        "A": "Different layers have different requirements",
        "B": "Prevents tight coupling between layers",
        "C": "Allows independent evolution of layers",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 94,
      "question": "What is the purpose of using sealed classes for UI state in MVVM?",
      "options": {
        "A": "To represent all possible UI states",
        "B": "Exhaustive when statements in Kotlin",
        "C": "Clear state management",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 95,
      "question": "How does WorkManager differ from AlarmManager?",
      "options": {
        "A": "WorkManager is for deferrable tasks, AlarmManager for exact timing",
        "B": "WorkManager handles Doze mode, AlarmManager doesn't",
        "C": "WorkManager can run tasks in background without app running",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 96,
      "question": "Why use DataStore instead of SharedPreferences?",
      "options": {
        "A": "DataStore uses Kotlin Coroutines and Flow",
        "B": "Type safety with Protocol Buffers",
        "C": "Better error handling",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 97,
      "question": "What is the benefit of using ConstraintLayout in Android?",
      "options": {
        "A": "Flat view hierarchy for better performance",
        "B": "Flexible positioning with constraints",
        "C": "Better responsive design",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 98,
      "question": "How to handle configuration changes in ViewModel?",
      "options": {
        "A": "ViewModel survives configuration changes automatically",
        "B": "Use SavedStateHandle for important data",
        "C": "Store data in onSaveInstanceState",
        "D": "Both A and B"
      },
      "correct_answer": "D"
    },
    {
      "id": 99,
      "question": "What is the purpose of using ProGuard/R8 in Android?",
      "options": {
        "A": "Code obfuscation for security",
        "B": "APK size reduction",
        "C": "Removing unused code",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 100,
      "question": "Why implement modular architecture in large apps?",
      "options": {
        "A": "Faster build times with parallel compilation",
        "B": "Better separation of concerns",
        "C": "Team autonomy and independent development",
        "D": "All of the above"
      },
      "correct_answer": "D"
    }
  ]
}